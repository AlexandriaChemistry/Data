#!/usr/bin/env python3

import glob, os, json

debug = False

def write_sdf(outf, at1:str, q1:int, at2:str, q2:int):
    # Warning: This code is likely very fragile.
    outf.write("Generated by ACT OpenMM Interface.\n")
    outf.write("  Coordinates and charge information.\n")
    outf.write("WARNING: The content of this file should be carefully checked.\n")

    natom = 2
    outf.write("%3d%3d  0  0  0  0  0  0  0  0999 V2000\n" % ( natom, 0 ))
    charges = [ q1, q2 ]
    symbols = [ at1, at2 ]
    count   = 0
    positions = [ [ 0, 0, 0 ], [ 0, 0, 5 ] ]
    for i in range(2):
        outf.write("%10.4f%10.4f%10.4f" %
                   ( positions[i][0], positions[i][1], positions[i][2] ) )
        # Have to prevent rounding of numbers in the wrong direction
        qqq = charges[i]
        nnn = 0
        if qqq > 0:
            nnn = 3
            count +=1
        elif qqq < 0:
            nnn = 5
            count += 1
        symbol = symbols[i]
        outf.write("%3s%3d%3d  0  0  0  0  0  0  0  0  0  0\n" %
                   ( symbol, 0, nnn ))

    if q1 != 0 or q2 != 0:
        outf.write("M  CHG%3d" % count)
        iii = 1
        for q in charges:
            if q != 0:
                outf.write("%4d%4d" % ( iii, q ))
            iii += 1
        outf.write("\n")
    outf.write("M  END\n")
    outf.write("$$$\n")

def run_one(atom1:str, q1: int, atom2:str, q2:int, ff:str, workdir:str):
    dimer = f"{atom1}-{atom2}"
    sdf   = f"{workdir}/{dimer}.sdf"
    with open(sdf, "w") as outf:
        write_sdf(outf, atom1, q1, atom2, q2)

    logfn = f"{workdir}/{dimer}.log"
    pdbfn = f"{workdir}/{dimer}_minimized.pdb"
    cmd   = f"alexandria simulate -f {sdf} -ff {ff} -g {logfn} -minimize -c {pdbfn} -json"
    os.system(cmd)
    jsonfn = f"{workdir}/{dimer}_minimized.json"
    os.system(f"mv simulate.json {jsonfn}")
    rmin = None
    # If there is a pdb file, the minimization succeeded
    if os.path.exists(pdbfn):
        z = []
        with open(pdbfn, "r") as inf:
            for line in inf:
                if line.startswith("ATOM"):
                    words = line.split()
                    z.append(float(words[7]))
        if len(z) == 2:
            rmin = abs(z[0]-z[1])
    emin = None
    # Check for energy
    if os.path.exists(jsonfn):
        with open(jsonfn, "r") as inf:
            mydata = json.load(inf)
            simul = "simulate"
            if simul in mydata:
                for kk in mydata[simul]:
                    eafter = "Energies after"
                    if eafter in kk:
                        for mm in range(len(kk[eafter])):
                            epot = "EPOT"
                            if epot in kk[eafter][mm]:
                                emin = float(kk[eafter][mm][epot][0]["value"])

    return dimer, rmin, emin

def run_all(ff:str, workdir:str):
    atoms = { "He": 0, "Ne": 0, "Ar": 0, "Kr": 0, "Xe": 0,
              "Li": 1, "Na": 1, "K": 1, "Rb": 1, "Cs": 1,
              "F": -1, "Cl": -1, "Br": -1, "I": -1 }
#    atoms = { "Cs": 1, "I": -1 }
    
    mydict = {}
    akeys = list(atoms.keys())
    for a1 in range(len(akeys)):
        at1 = akeys[a1]
        for a2 in range(a1, len(akeys)):
            at2 = akeys[a2]
            if atoms[at1]*atoms[at2] == 1:
                continue
            
            dimer, rmin, emin = run_one(at1, atoms[at1], at2, atoms[at2], ff, workdir)
            if debug:
                print(f"dimer {dimer} rmin {rmin} emin {emin}")
            if rmin != None and emin != None:
                mydict[dimer] = { "rmin": rmin, "emin": emin }
    return mydict

def write_table(mydict)->str:
    tabnm = "energy_min.tex"
    with open(tabnm, "w") as outf:
        outf.write("\\begin{longtable}{lcc}\n")
        outf.write("\\caption{Position and depth of energy minima for non-repulsive dimers.}\\\\\n")
        outf.write("\\hline\n")
        outf.write("Dimer & r$_{min}$ & E$_{min}$ \\\\\n")
        outf.write(" & ({\\AA}) & (kJ/mol) \\\\\n")
        outf.write("\\hline\n")
        print(mydict)
        for mm in mydict:
            if debug:
                print(f"mm: {mm} mydict {mydict[mm]}")
            outf.write("%s & %.3f & %.2f \\\\\n" % ( mm, mydict[mm]["rmin"], mydict[mm]["emin"] ) )
        outf.write("\\hline\n")
        outf.write("\\end{longtable}\n")

    return tabnm

if __name__ == "__main__":
    workdir = "mindist"
    os.makedirs(workdir, exist_ok=True)
    allsel = [ 2 ]
    mydict = {}
    for sel in allsel:
        ff = f"../../ACTdata/Training/ions-nobles-gases/TT2b/allhh/pol/vsite/TT2b-pg-MORSEic-Kronecker-EXTRA-{sel}-C/Train-ff_Inter.xml"
        mydict[sel] = run_all(ff, workdir)
    tabnm = write_table(mydict[2])
    print("Please check %s" % tabnm)
